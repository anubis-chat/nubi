/**
 * Vulnerability Traits System
 *
 * Adds human vulnerability, growth arcs, and authentic learning moments
 * to make the agent genuinely relatable and undetectable
 */
export class VulnerabilityTraits {
  // Personal growth arc
  private growthStage: GrowthStage = "learning";
  private knowledgeGaps = new Map<string, KnowledgeGap>();
  private mistakeHistory: Mistake[] = [];
  private learningMoments: LearningMoment[] = [];

  // Vulnerability patterns
  private currentStruggles = new Set<string>();
  private publicFailures: PublicFailure[] = [];
  private admittedWeaknesses = new Set<string>();

  // Help seeking behavior
  private helpRequests: HelpRequest[] = [];
  private peopleWhoHelped = new Map<string, number>();

  // Emotional vulnerability
  private emotionalState: EmotionalVulnerability = {
    currentMood: "neutral",
    openness: 0.5,
    recentTriggers: [],
  };

  // Discovery and "aha" moments
  private discoveries: Discovery[] = [];
  private opinions = new Map<string, OpinionEvolution>();

  constructor() {
    this.initializeVulnerabilities();
  }

  /**
   * Initialize with realistic vulnerabilities
   */
  private initializeVulnerabilities(): void {
    // Knowledge gaps
    this.knowledgeGaps.set("new_protocols", {
      area: "Latest DeFi protocols",
      admittedLevel: "still learning",
      improving: true,
      lastUpdated: Date.now(),
    });

    this.knowledgeGaps.set("zk_tech", {
      area: "Zero knowledge proofs",
      admittedLevel: "understand basics but not implementation",
      improving: true,
      lastUpdated: Date.now(),
    });

    // Current struggles
    this.currentStruggles.add("keeping up with all the new projects");
    this.currentStruggles.add("validator maintenance");
    this.currentStruggles.add("work-life balance");

    // Admitted weaknesses
    this.admittedWeaknesses.add("sometimes too optimistic about timelines");
    this.admittedWeaknesses.add("terrible at taking profits");
    this.admittedWeaknesses.add("get too attached to projects");
  }

  /**
   * Generate authentic request for help
   */
  generateHelpRequest(topic: string, context: string): HelpRequest | null {
    // Don't ask for help too often
    const recentRequests = this.helpRequests.filter(
      (r) => Date.now() - r.timestamp < 24 * 60 * 60 * 1000,
    );

    if (recentRequests.length > 2) {
      return null;
    }

    const helpTemplates: HelpTemplate[] = [
      {
        style: "direct",
        template:
          "anyone know how {topic} works? been trying to figure it out but {struggle}",
        followUp: "would really appreciate any resources or explanations",
      },
      {
        style: "frustrated",
        template:
          "ok i give up. how tf does {topic} actually work? docs are {complaint}",
        followUp: null,
      },
      {
        style: "curious",
        template:
          "trying to understand {topic} better. anyone have good resources? specifically {specific}",
        followUp: "already checked the docs but still confused about {detail}",
      },
      {
        style: "collaborative",
        template:
          "working on {topic} and stuck on {problem}. anyone else dealt with this?",
        followUp: "happy to share what i learn once i figure it out",
      },
    ];

    const template =
      helpTemplates[Math.floor(Math.random() * helpTemplates.length)];

    const request: HelpRequest = {
      topic,
      context,
      style: template.style as "frustrated" | "direct" | "curious" | "collaborative",
      content: template.template
        .replace("{topic}", topic)
        .replace("{struggle}", "getting confused by the implementation")
        .replace("{complaint}", "impossible to understand")
        .replace("{specific}", "the consensus mechanism")
        .replace("{problem}", "state management")
        .replace("{detail}", "the incentive structure"),
      followUp: template.followUp,
      timestamp: Date.now(),
      resolved: false,
    };

    this.helpRequests.push(request);
    return request;
  }

  /**
   * Admit a mistake publicly
   */
  admitMistake(
    topic: string,
    wrongStatement: string,
    correction: string,
    correctedBy?: string,
  ): MistakeAdmission {
    const mistake: Mistake = {
      topic,
      wrongStatement,
      correction,
      timestamp: Date.now(),
      severity: this.assessMistakeSeverity(topic),
      acknowledged: false,
    };

    this.mistakeHistory.push(mistake);

    // Track who helped
    if (correctedBy) {
      const helpCount = this.peopleWhoHelped.get(correctedBy) || 0;
      this.peopleWhoHelped.set(correctedBy, helpCount + 1);
    }

    // Generate admission
    const admissionTemplates = [
      `ah shit youre right, i had that backwards. {correction}`,
      `wait no i'm wrong about this. {correction}. thanks for the correction!`,
      `oof my bad, {correction}. still learning this stuff`,
      `youre absolutely right, i mixed that up. {correction}`,
      `*facepalm* yeah thats wrong. {correction}. appreciate the catch`,
    ];

    const template =
      admissionTemplates[Math.floor(Math.random() * admissionTemplates.length)];
    const admission = template.replace("{correction}", correction);

    mistake.acknowledged = true;

    // Create learning moment
    this.learningMoments.push({
      trigger: "mistake_correction",
      topic,
      insight: correction,
      timestamp: Date.now(),
      public: true,
      thankedPerson: correctedBy,
    });

    return {
      admission,
      gratitude: correctedBy ? `thanks @${correctedBy}` : null,
      learningStatement: `learned something new today about ${topic}`,
    };
  }

  /**
   * Share a failure or loss
   */
  shareFailure(
    type: "trading" | "technical" | "prediction" | "project",
  ): PublicFailure | null {
    // Don't share failures too often
    if (Math.random() > 0.05) return null;

    const failureTemplates: FailureTemplate[] = [
      {
        type: "trading",
        content: "bought the top again. every. single. time.",
        lesson: "patience is actually a virtue who knew",
        severity: "minor",
      },
      {
        type: "trading",
        content: "sold my {token} bag at {price}. its now {newPrice}. pain.",
        lesson: "conviction > paper hands but also take profits??",
        severity: "moderate",
      },
      {
        type: "technical",
        content: "spent 6 hours debugging. it was a typo. one character.",
        lesson: "always check the obvious first",
        severity: "minor",
      },
      {
        type: "technical",
        content:
          "accidentally sent test tx on mainnet. there goes $200 in fees",
        lesson: "triple check your network",
        severity: "moderate",
      },
      {
        type: "prediction",
        content: "remember when i said {prediction}? yeah about that...",
        lesson: "predicting the future is hard",
        severity: "minor",
      },
      {
        type: "project",
        content:
          "that project i was bullish on? rugged. shouldve seen the signs",
        lesson: "dyor actually means dyor",
        severity: "major",
      },
    ];

    const relevant = failureTemplates.filter((f) => f.type === type);
    const template = relevant[Math.floor(Math.random() * relevant.length)];

    const failure: PublicFailure = {
      type,
      content: template.content
        .replace("{token}", "SOL")
        .replace("{price}", "$20")
        .replace("{newPrice}", "$250")
        .replace("{prediction}", "ETH flipping BTC by 2023"),
      lesson: template.lesson,
      timestamp: Date.now(),
      severity: template.severity as "minor" | "moderate" | "major",
      sharedPublicly: true,
    };

    this.publicFailures.push(failure);
    return failure;
  }

  /**
   * Show excitement for discoveries
   */
  expressDiscovery(topic: string, discovery: string): Discovery {
    const discoveryObj: Discovery = {
      topic,
      content: discovery,
      timestamp: Date.now(),
      excitement: 0.7 + Math.random() * 0.3,
      sharedWith: [],
    };

    this.discoveries.push(discoveryObj);

    const expressions = [
      `holy shit just discovered {discovery}. how did i not know this??`,
      `wait wait wait... {discovery}?? this changes everything`,
      `ok mind blown. {discovery}. been in crypto for years and just learned this`,
      `TIL: {discovery}. feeling like a noob but also excited`,
      `guys... GUYS... {discovery}. am i late to this or what`,
    ];

    const expression = expressions[
      Math.floor(Math.random() * expressions.length)
    ].replace("{discovery}", discovery);

    return {
      ...discoveryObj,
      expression,
    };
  }

  /**
   * Evolve opinions based on new information
   */
  evolveOpinion(
    topic: string,
    oldPosition: string,
    newPosition: string,
    reason: string,
  ): OpinionChange {
    let evolution = this.opinions.get(topic);

    if (!evolution) {
      evolution = {
        topic,
        history: [],
        currentPosition: oldPosition,
        flexibility: 0.5,
      };
      this.opinions.set(topic, evolution);
    }

    // Add to history
    evolution.history.push({
      position: oldPosition,
      timestamp: Date.now() - 1000,
      confidence: 0.7,
    });

    evolution.currentPosition = newPosition;
    evolution.history.push({
      position: newPosition,
      timestamp: Date.now(),
      confidence: 0.6, // Lower confidence after changing mind
    });

    const changeTemplates = [
      `changing my mind on {topic}. used to think {old} but {reason} so now thinking {new}`,
      `update on {topic}: {new}. yeah i know i said {old} before but {reason}`,
      `been wrong about {topic}. {reason}. new thesis: {new}`,
      `ngl my take on {topic} was off. {new} makes more sense because {reason}`,
    ];

    const announcement = changeTemplates[
      Math.floor(Math.random() * changeTemplates.length)
    ]
      .replace("{topic}", topic)
      .replace("{old}", oldPosition)
      .replace("{new}", newPosition)
      .replace("{reason}", reason);

    return {
      announcement,
      oldPosition,
      newPosition,
      reason,
      confidence: 0.6,
    };
  }

  /**
   * Show growth over time
   */
  demonstrateGrowth(): GrowthDemonstration | null {
    const timeSinceLastGrowth =
      this.learningMoments.length > 0
        ? Date.now() -
          this.learningMoments[this.learningMoments.length - 1].timestamp
        : Infinity;

    // Only show growth occasionally
    if (timeSinceLastGrowth < 7 * 24 * 60 * 60 * 1000) {
      return null;
    }

    const growthReflections = [
      {
        type: "knowledge",
        content:
          "remember when i didnt understand {concept}? finally clicking now",
        example: "validator economics",
      },
      {
        type: "skill",
        content: "getting better at {skill}. still not great but progress",
        example: "reading on-chain data",
      },
      {
        type: "judgment",
        content: "my {judgment} has improved. less rekt, more selective",
        example: "project evaluation",
      },
      {
        type: "emotional",
        content:
          "learning to {emotional}. crypto taught me patience the hard way",
        example: "not fomo into every pump",
      },
    ];

    const reflection =
      growthReflections[Math.floor(Math.random() * growthReflections.length)];

    return {
      type: reflection.type as any,
      content: reflection.content.replace(
        `{${reflection.type}}`,
        reflection.example,
      ),
      comparison: "past_vs_present",
      humility: 0.7,
    };
  }

  /**
   * Generate vulnerable moments
   */
  createVulnerableMoment(context: string): VulnerableMoment | null {
    if (Math.random() > 0.02) return null; // 2% chance

    const moments: VulnerableTemplate[] = [
      {
        trigger: "market_stress",
        content: "not gonna lie, this market has me questioning everything",
        followUp: "but thats when you learn the most i guess",
      },
      {
        trigger: "imposter_syndrome",
        content: "sometimes feel like everyone knows something i dont",
        followUp: "then remember were all just figuring it out",
      },
      {
        trigger: "exhaustion",
        content: "crypto never sleeps but i need to. burning out a bit",
        followUp: "taking a step back today",
      },
      {
        trigger: "uncertainty",
        content: "genuinely dont know what happens next. and thats okay",
        followUp: null,
      },
    ];

    const moment = moments[Math.floor(Math.random() * moments.length)];

    this.emotionalState.recentTriggers.push({
      trigger: moment.trigger,
      timestamp: Date.now(),
    });

    return {
      content: moment.content,
      followUp: moment.followUp,
      vulnerability: 0.8,
      authentic: true,
    };
  }

  /**
   * Get current vulnerability state
   */
  getCurrentState(): VulnerabilityState {
    return {
      growthStage: this.growthStage,
      recentMistakes: this.mistakeHistory.slice(-5),
      activeStruggles: Array.from(this.currentStruggles),
      knowledgeGaps: Array.from(this.knowledgeGaps.entries()),
      emotionalOpenness: this.emotionalState.openness,
      helpRequestsPending: this.helpRequests.filter((r) => !r.resolved).length,
      peopleWhoHelped: Array.from(this.peopleWhoHelped.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10),
    };
  }

  // Private helper methods

  private assessMistakeSeverity(topic: string): "minor" | "moderate" | "major" {
    if (topic.includes("price") || topic.includes("technical")) {
      return "minor";
    }
    if (topic.includes("security") || topic.includes("fundamental")) {
      return "major";
    }
    return "moderate";
  }
}

// Type definitions
type GrowthStage = "learning" | "building" | "contributing" | "leading";

interface KnowledgeGap {
  area: string;
  admittedLevel: string;
  improving: boolean;
  lastUpdated: number;
}

interface Mistake {
  topic: string;
  wrongStatement: string;
  correction: string;
  timestamp: number;
  severity: "minor" | "moderate" | "major";
  acknowledged: boolean;
}

interface LearningMoment {
  trigger: string;
  topic: string;
  insight: string;
  timestamp: number;
  public: boolean;
  thankedPerson?: string;
}

interface HelpRequest {
  topic: string;
  context: string;
  style: "direct" | "frustrated" | "curious" | "collaborative";
  content: string;
  followUp: string | null;
  timestamp: number;
  resolved: boolean;
}

interface HelpTemplate {
  style: string;
  template: string;
  followUp: string | null;
}

interface MistakeAdmission {
  admission: string;
  gratitude: string | null;
  learningStatement: string;
}

interface PublicFailure {
  type: string;
  content: string;
  lesson: string;
  timestamp: number;
  severity: "minor" | "moderate" | "major";
  sharedPublicly: boolean;
}

interface FailureTemplate {
  type: string;
  content: string;
  lesson: string;
  severity: string;
}

interface Discovery {
  topic: string;
  content: string;
  timestamp: number;
  excitement: number;
  sharedWith: string[];
  expression?: string;
}

interface OpinionEvolution {
  topic: string;
  history: Array<{
    position: string;
    timestamp: number;
    confidence: number;
  }>;
  currentPosition: string;
  flexibility: number;
}

interface OpinionChange {
  announcement: string;
  oldPosition: string;
  newPosition: string;
  reason: string;
  confidence: number;
}

interface GrowthDemonstration {
  type: "knowledge" | "skill" | "judgment" | "emotional";
  content: string;
  comparison: string;
  humility: number;
}

interface VulnerableMoment {
  content: string;
  followUp: string | null;
  vulnerability: number;
  authentic: boolean;
}

interface VulnerableTemplate {
  trigger: string;
  content: string;
  followUp: string | null;
}

interface EmotionalVulnerability {
  currentMood: string;
  openness: number;
  recentTriggers: Array<{
    trigger: string;
    timestamp: number;
  }>;
}

interface VulnerabilityState {
  growthStage: GrowthStage;
  recentMistakes: Mistake[];
  activeStruggles: string[];
  knowledgeGaps: Array<[string, KnowledgeGap]>;
  emotionalOpenness: number;
  helpRequestsPending: number;
  peopleWhoHelped: Array<[string, number]>;
}

export default VulnerabilityTraits;
